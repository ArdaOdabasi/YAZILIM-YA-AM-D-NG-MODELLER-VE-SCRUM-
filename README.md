# YAZILIM-YA-AM-D-NG-MODELLER-VE-SCRUM-
YAZILIM YAŞAM DÖNGÜ MODELLERİ VE SCRUM 
           Bir yazılımın geliştirilmesi ve onarımı boyunca uygulanan adımlar topluluğuna yaşam-döngü modeli denir.Çağlayan Yaşam-Döngü Modeli, Kodla ve Düzelt Yaşam-Döngü Modeli, V Süreç Modeli, Helezonik (Spiral) Model ve Artımsal Geliştirme Yaşam-Döngü Modeli yazılım sektöründe yaygın olarak kullanılan ve bilinen yazılım yaşam-döngü modelleridir.
           
           60'lı yıllarda, üretim ortamlarında kullanılan gelişigüzel model her ne kadar bu üretim ortamlarında kullanılsada bu yöntem günümüzde bir model olarak adlandırılmamaktadır. Bu yöntemi bir geliştirme çeşidi olarak adlandırmak daha doğru olacaktır. Bunun sebeplerinden biri yöntemin bir modeli temel almamasıdır. Genellikle geliştiren kişiye bağımlıdır ve geliştiren kişiden bağımsız bir model olarak düşünülemez.Sadece geliştiren kişiye bağlı olduğu için yazılımda çıkan herhangi bir problemin çözülmesi oldukça güçtür.Ve bu yönü dolayısıyla yazılımın izlenilebilirliği ve bakım yapılabilirliği zordur.Sonuç olarak gelişigüzel geliştirme yöntemi tek bir kişiye bağımlı olan basit bir programlama yöntemidir.Günümüzde kullanımı önerilmeyen ve 1970'li yıllarda kullanılan barok modeli ise bir başka yazılım geliştirme modelidir.Barok modelinde gerçekleştirim aşamasına daha çok önem verilmiştir ve modelde yaşam döngüsünün temel adımları doğrusal bir biçimde geliştirilmiştir.1970'li yılların ortalarında kullanılmaya başlayan bu model belgelemeyi ayrı bir süreç olarak ele alır.Bu belgeleme süreci yazılımın geliştirilmesi ve yazılımın testinden hemen sonra yapılmaktadır.Modelin adımları arasında geri dönüşlerin nasıl yapılacağına dair bir tanımlama yoktur.Gelişigüzel model gibi barok modeli de günümüzde yaygın olarak kullanılmamaktadır.Geleneksel yazılım geliştirme modeli olarak bilinen çağlayan yaşam-döngü modeli de yazılım geliştirme modellerinden biridir.Bu modele şelale (waterfall) modeli de denmektedir.Bu modelde yaşam döngüsünün temel adımları baştan sona en az bir kez
gerçekleştirilmektedir.Bu sebeple tanınmış en temel modeldir.Geçmişte de en popüler yazılım geliştirme modeli olarak bilinmektedir. Küçük ve gereksinimi iyi anlaşılmış projeler için uygun bir modeldir ve bu modelin kullanımı günümüzde giderek azalmaktadır.Bu modelde belgeme işlemini ayrı bir aşama olarak ele alan barok modelinin tam aksine belgeleme işlemi üretimin doğal bir parçası olarak ele alınmaktadır ayrıca yine barok modelinin aksine adımlar arasında geri dönüşler tanımlanmıştır.Modelde ilk olarak gereksinimlerin tanımlanması yapılır.Ardından sistem ve yazılım tasarımı yapılır.Beraberinde gerçekleştirme ve birim test etapları gerçekleştirilir.Sonrasında yapıyı birleştirme ve test işlemi yapılmaktadır.Son olarak bakım ve işlem aşaması gerçekleştirilir. Gereksinimlerin tanımlanması adımında gerçekleştirilecek sistemin gereksinimleri belirlenir.Müşterinin istekleri,ürünün yapması gerekenler ve işlevleri bu adımda belirlenir.Sistem ve yazılım tasarımı aşamasında ise gereksinimleri belirlenmiş bir sistemin yapısal ve detay tasarımı oluşturulur.Ürünün müşterinin beklediği işlevselliği nasıl sağlayacağının cevapları bu aşamada bulunur.Gerçekleştirme ve birim test aşamasında tasarımı yapılmış bir yazılım sisteminin kodlama işlemi yapılır.Yazılım ürününün tasarımı gerçekleştirecek şekilde kodlanması bu adımda sorgulanır.Yapıyı birleştirme ve sistem testi aşamasında gerçekleştirilmiş sistemin beklenen özellikleri gösterip göstermediğini kontrol edilir.Ürünün müşterinin beklediği işlevselliği sağlayıp sağlamadığı bu adımda sorgulanır.Son olarak işlem ve bakım aşamasında ise müşteriye teslim edilmiş ürün üzerinde değişen ihtiyaçlara ve değişen müşteri taleplerine göre güncelleme işlemi yapılır.Ürünün müşteri tarafından memnuniyetle kullanılıp kullanılmadığının cevabı aranır ve bu cevaplar doğrultusunda kararlar alınır.Bu modelde adımlar aşama izlenir aşamaların sıralaması önemlidir bir adım bitmeden diğer adıma geçilemez.Bütün adımlarda belgeleme işlemi yapılmaktadır.Eğer bir adımda test ve belgeleme işlemi yapılmamışsa o adımın tamamlandığı kabul edilmez.Çağlayan modelinin avantajları ve dezavantajları vardır.Avantajlara örnek olarak, müşteriler ve son kullanıcılar tarafından iyi anlaşılabilen adımlardan oluşması,değişiklik sürecinin yönetilebilir birimlere bölünmesi verilebilir.Ayrıca gereksinim adımından sonra sağlam bir temel oluşturulur.Projeyi yöneten kişiler açısından işin dağılımını yapmak kolaydır.Bu model sayesinde projenin aşamaları ve gereksinimleri iyi anlaşılabilir ve gereksinimleri iyi anlaşılabilen projelerin iyi çalışma ihtimali yüksektir.Bu modelin avantajları olduğu gibi yol açacağı problemlerde vardır.Örneğin test aşamasının en sonda yapılması hataların erken teşhisini engeller ve projede yeniden tasarım gerektirir.Bunun önüne geçmek için çözümleme aşamasının önüne bir ön tasarım aşaması eklenebilir veya her aşamanın sonunda geniş bir belgelendirme yapılabilir.Erken aşamalarda belgelendirme etkili bir yeniden tasarıma izin verir.Diğer bir problem ise kullanıcı veya kullanıcıların yazılım kalitesini sadece en son aşamada anlayabilecek olmalarıdır.Bunun önüne geçmek için her adımda müşteri sürece dahil edilmelidir.Çağlayan modelinin dezavantajlarına örnek vermek gerekirse Bitirme kriterinin belgelendirme ile sınırlandırılması örnek verilebilir.Derleyiciler,işletim sistemleri, vb etkileşimli son kullanıcı uygulamaları gibi alanlar için bu kritere uymak oldukça zordur.Geliştirme sürecinde gereksinimlerin sürekli değişkenlik göstermesi de bir dezavantajdır.Bu yüzden çağlayan modeli gereksinimlerin çok iyi anlaşılabildiği durumlarda kullanılmalıdır.Yazılımın kullanıcıya ulaşma zamanı uzundur.Ayrıca ihtiyaç tanımlamaları çoğu kez açık şekilde yapılamadığından ötürü, eksikleri gidermek maliyetleri artırır.Kullanıcıların ürünü görme zamanının uzun tutulması, projenin bitmeyeceği gibi kullanıcı tarafından şüphe uyandıran sorunlara yol açabilir.Çağlayan modeli dinamik bir model değildir yani değişimlere elverişsizdir. Büyük yazılım projelerinde sürekli farklı fikirler ve ihtiyaçlar ortaya çıktığı için geri dönüş yapmak zordur.Bu yüzden müşterinin istekleri iyi bir şekilde anlaşılmalı ve gereksinimler detaylı bir şekilde analiz edilmek zorundadır.Bir başka yazılım-yaşam döngü modeli de V modelidir.Bu süreç adımları kodlama aşamasına kadar aşağıya doğru eğim alır ve kodlama aşamasından sonra yukarıya doğru eğim alır böylelikle V şeklini oluşturur bu yüzden bu ismi almıştır.Bu model Çağlayan modelinden biraz daha gelişmiştir.Sol taraf üretim, sağ taraf ise sınama bölümüdür.3 temel çıktıdan oluşur bunlardan ilki kullanıcı modelidir.Bu modelde geliştirme sürecinin kullanıcı ile olan ilişkileri tanımlanır ve sistemin nasıl kabul edileceğine ilişkin test planları ortaya çıkarılır.İkinci model mimari modeldir.Sistem tasarımı ve oluşacak alt sistem ile tüm sistemin test işlemlerine ilişkin işlevler buradadır.Üçüncü model ise  gerçekleştirim modelidir.Bu aşamada yazılım modüllerinin kodlanması ve test edilmesine ilişkin fonksiyonlar bulunur.Bu modelin avantajları, v modelinde hangi aşamanın ne şekilde test edileceği belirgin bir şekilde gösterilmesidir.Bu sayede yapılanların testi ve doğrulanması planlı bir sistematik disipline taşınır. Böylece hataların daha kolay fark edilmesi ve düzeltilmesi sağlanabilir.Dezavantajları ise, v modelinin, çağlayan modelinin test kısmı standartlaştırılmış bir türü olduğu ve yeni bir şey getirmediği ileri sürülmektedir. Şelale modelindeki ihtiyaçların ilerleyen aşamalarda anlaşılması, maliyetli geri dönüşler ve ekibin projeye dahil olmasının gecikmesi gibi dezavantajlar V-modelinde de görülebilmektedir.V- modeli, planlama açısından da şelale modeliyle benzerlik gösterir. Ancak kontrol aşama ve testlerinin standartlaşması bunların unutulmasını önler. Test öncelikli geliştirme kullanılarak testin ilk anda yapılması önemli yarar sağlar. Yapılacak çalışma ile eşleştirilmesi, bu konulardan sorumlu ekiplerin erken aşamalarda birlikte çalışmasını sağlar. Örneğin mimari ile test ekibi birlikte çalışarak, projenin bütünleştirme test senaryosunu hazırlayabilir. Böylece zaman daha etkin kullanılır.Bir başka yazılım tasarım modeli ise helezonik modeldir.Planlama, risk analizi, üretim ve kullanıcı değerlendirmesi olarak 4 ana aşamadan oluşur. Sarmal modeli aynı safhalara geri dönülmesinin bir zorunluluk olduğunu vurgular, Sarmal modeli şelale modelinde yok sayılan riskleri göz önünde bulundurur, Proje çevrimlere ayrılır ve her bir çevrimin riskleri ayrı ayrı ele alınır. Çağdaş modellere son derece yakındır. Planlama aşamasında üretilecek ara ürün için planlama yapılır ve amaç belirlenir ayrıca bir önceki adımda üretilen ara ürün ile bütünleştirme işlemi yapılır.Risk Analizi aşamasında ise risk seçeneklerinin araştırılır ve riskler belirlenir.Üretim aşamasında ara ürünün üretililir son olarak kullanıcı değerlendirmesi aşamasında ise ara ürün ile ilgili olarak kullanıcı tarafından yapılan testler ve değerlendirmeler vardır.Bu modelin avantajları ise şöyledir, kullanıcılar sistemi erken görebilirler.Geliştirmeyi küçük parçalara böler.En riskli kısımlar önce gerçekleştirilir.Pek çok yazılım modelini içinde bulundurur.Riske duyarlı yaklaşımı potansiyel zorlukları engeller.Seçeneklere erken dikkate odaklanır.Hataları erken gidermeye odaklanır.Yazılım-donanım sistemi geliştirme için bir çerçeve sağlar.Dezavantajları ise şöyledir, Küçük ve düşük riskli projeler için pahalı bir yöntemdir.Komplekstir (karmaşık)Spiral sonsuza gidebilirAra adımların fazlalılığı nedeniyle çok fazla dokümantasyon gerektirir.Büyük ölçekte projeler vardır.Kontrat tabanlı yazılıma uymaz.Yazılımın içten geliştirileceğini varsayar.Kontrat tabanlı yazılımlar adım adım anlaşma esnekliğini sağlamaz.Öznel risk değerlendirme deneyimine dayanır.Yüksek riskli öğelere yoğunlaşmak, yüksek riskli öğelerin doğru belirlenmesini gerektirir.Bir başka yazılım geliştirme modeli ise artımsal geliştirme süreç modelidir.Artırımsal model bir takvime bağlı olarak yazılımı kesim kesim geliştirip teslim etmeye dayanır.Her bir yeni kesim öncekinin üstüne bazı ek işlevlerin eklenmesini öngörür.Artırımsal model yazılım geliştirmenin kısıtlı sayıda çalışanla işin yapılmasını sağlama gibi bir üstünlüğü vardır.Ayrıca çalışanlar da her artırım geçildiğinde uygulama alanına ilişkin daha çok deneyim kazanmış olurlar. Bu modelde bir taraftan üretim bir taraftan da kullanım yapılır.Önceki modellerde ürünlerdeki değişiklikler göz önünde bulundurulmaz.Bu model doğal olarak yinelemelidir. Yeniden kullanılabilir bir ürün, fonksiyonellik sağlamış bir şekilde tüm döngülerin sonunda ortaya çıkar.Avantajları şunlardır, sistem için gerekli olan gereksinimler müşterilerle belirlenir.Gereksinimlerin önemine göre teslim edilecek art ımlar belirlenir.Öncelikle en önemli gereksinimleri karşılayan çekirdek bir sitem geliştirilir.Erken artımlar prototip gibi davranarak, gereksinimlerin daha iyi anlaşılmasını sağlar.Tüm projenin başarısız olma riskini azaltır.En önemli sistem özellikleri daha fazla sınanma (test edilme) imkanı bulmuş olur.Divide and Conquer (Böl ve Yönet) yaklaşımıdır Dezavantajları ise şunlardır, artımları tanımlamak için tüm sistemin tanımlanmasına ihtiyaç vardır.Gereksinimleri doğru boyuttaki artımlara atamak bazen zor olabilir.Deneyimli personel gerektirir.Artımların kendi içlerinde tekrarlamalara izin vermez.Bir diğer yazılım modeli ise kodla ve düzelt yaşam döngü modelidir.Bu model genellikle resmi olmayan bir ürün fikriyle başlar ve program ürün “hazır” olana kadar ya da gerekli zaman bitene kadar kodlama yapılarak devam eder.Avantajları ise şunlardır, herhangi bir planlamaya ihtiyaç duyulmaz.Çok küçük projelerde ya da kısa ömürlü prototiplerde 
uygulanabilir.Program aşamaları çabuk geçilir.Uzman görüşüne ihtiyaç düşüktür herkes bu modeli kullanabilir.Dezavantajları ise şunlardır, kontrollü değildir.Kaynak planlaması yoktur.Bitiş süresi belli değildir.Hataların bulunması ve doğrulaması zordur.Kodları düzeltmek maliyetli olabilir.Kodlar kullanıcının ihtiyacını karşılamayabilir.Kodlar sonradan değiştirmek için planlanmadığından esnek değildir, değiştirilmesi zordur.

           Makalede ele alacağımız bir başka konu ise günümüzde popüler olan Scrum`dır. Scrum yaklaşımı en popüler Agile yöntemidir. Büyük ve karışık yazılım süreçlerinin yönetilmesinde tercih edilen Scrum bütünü parçalamaya ve tekrara dayalı bir yöntemdir.Scrum sayesinde Projenin açık ve net olması hem zaman kazandırır hem de projenin başarılı sonuçlanmasını sağlar.Projenin anlaşılabilir ve yönetilebilir parçalara ayrılması olası sorunları hızlı bir şekilde tespit etmekte ve düzeltmekte zaman kazandırır.Bütün ekibin, projenin tüm akışından haberdar olması takım içindeki iletişimi artırır.Müşteri ile geliştiriciler arasında güven oluşur ve böylelikle projenin başarılı sonuçlanması beklenir.Scrum yönteminin doğru ve anlaşılır bir şekilde uygulanmasını sağlayan kişiye Scrum Master denir. Bu kişi sorumluklarını takımın Scrum yöntemine ve pratiğine uyulmasına sağlayarak gerçekleştirir. Ayrıca takımdaki kişilerin karşılaştıkları sorunların giderilmesine yardımcı ve destek olan kişidir. 3 temel prensip üzerine kurulmuştur.1.olarak Şeffaflık: Projedeki ilerlemeler ve sorunlar günlük olarak tutulur. Sorunlar ve gelişmeler herkes tarafından görülebilir olmalıdır.2.olarak Denetleme: Projenin ilerleyişi düzenli olarak teslim edilir ve değerlendirilir.3.olarak Uyarlama: Proje için gereksinimler bir defalığına belirlenmez. Her teslimatta gereksinimler yeniden belirlenir.Duruma göre projede uyarlamalar yapılır.Gereksinimlerin tam olarak tanımlanamadığı yazılım projeleri için en uygun metodolojidir. Bu metodolojide bir yinelemenin tamamlanması 2–4 haftadan (30 gün) fazla sürmemekte ve günlük 15 dakikalık toplantılarla sürekli iş takibi yapılmaktadır.Scrum`da da bazı kavramlar bulunmaktadır.Bu kavramlardan rolleri ele alalım.Pig Roller, Scrum sürecine dahil olanlar yani projede asıl işi yapan kişilerdir. Bunlar Ürün Sahibi, Scrum Yöneticisi ve Scrum Takımı’dır.1.Ürün Sahibi (Product Owner): Stratejik ürün geliştirmeden sorumludur. Ürünün tasarımı, iletişimi, özelliklerinin tanımı ve teslim edilen sprintin işlevselliği ve kabul edilebilir olup olmadığına karar verme sorumluluklarını üstlenir.2. Scrum Yöneticisi (Scrum Master): Scrum’un başarılı olmasını sağlamaktan sorumludur. Yazılım takımı ile birlikte çalışır. Ürün sahibi ile yazılım takımına destek olmak, engelleri kaldırmak ve süreçteki sapmaları düzenlemek, takımın dış etkilerden korunmasını ve kendi işine yoğunlaşmasını sağlayarak üretkenliğin artmasından sorumludur.3.Scrum Takımı (Scrum Team): Scrum Takımı, devamlı iletişim halinde olan ve tek bir hedefe ulaşmak için mücadele eden kişilerden oluşur. Takımın görevi ürün sahibinin taleplerine ve sıralamasına uygun ürünün işlevselliğini sağlamak ve belirlenen kalite standartlarına uymak koşuluyla ürünü teslim etmektir. Kendi kendilerini organize ederler. Bir takım 5–9 kişiden oluşur. Projenin geliştirilmesi ile ilgili sorumluluk takıma aittir.Chicken Roller; Scrum’un işleyişinde aktif olarak yer almayan kişilerdir. Müşteriler, satıcılar gibi.Toplantılar ile ilgili kavramları ele alalım.1. Koşu Planlama (Sprint Planning): Ürün gereksinim dokümanı ile belirtilen gereksinimler, bu toplantı ile geliştirme takımı tarafından küçük görevlere ayrılır. Risklerin değerlendirilmesi ve risk kontrollerinin belirlenmesi, gözden geçirmeler ve olası gereksinim değişikliklerinin belirlenmesi, geliştirme araçları ve altyapının onaylanması, dağıtım, geliştirme ve pazarlama maliyetlerinin hesaplanması, yönetimi ve destekleri gözden geçirme ve onaylama gibi işlemler bu planlama toplantısında gerçekleşir.2.Koşu Gözden Geçirme (Sprint Review): Her sprint sonunda yapılır. Yapılan sprint gözden geçirilir, ortaya çıkan ürün değerlendirilir. Amaç yazılımın ürün sahibinin gereksinimlerine uygun olarak geliştirildiğinden emin olmaktır.3.Günlük Scrum Toplantısı (Daily Scrum Meeting): Her gün belirtilen saatte ayak üstü yapılan 15 dakikalık toplantılardır ve tüm takım katılır. Bu toplantı gelecek 24 saati planlamak üzere yapılır. Takımın ilerleyişini ve karşılaştıkları engelleri görmek için önemli bir fırsattır. Takımdaki her üye dün ne yaptım, bugün ne yapacağım, işimi engelleyen herhangi bir sorun var mı sorularına cevap verir. Bu sayede herhangi bir sorun var ise scrum master bu probleme çözüm arar ve problemi ortadan kaldırır.4. Koşu Geçmişine Bakış (Sprint Retrospective): Geçmiş sprintteki tecrübeler masaya yatırılarak iyileştirmeler belirlenir. “Neleri daha iyi yapabiliriz?”, “Nasıl daha iyi yapabiliriz?” sorularına cevap aranır.Bileşenler ve Araçlar ile ilgili kavramları ele alalım.1. Ürün Gereksinim Dokümanı (Product Backlog): Proje için gerekli olan gereksinimler listesidir. Geçerli ve kullanışlı olması için devamlı bakım gerekir. Ürün sahibi tarafından gereksinimler alınır, öncelik sırasına göre sıralanır. Ürün sahibi, değişen ihtiyaçlara göre listeye ekleme veya çıkarma yapabilir. Listedeki sıralamalar her gün değişiklik gösterebilir. Ürün Gereksinim Listesi, kullanıcı bakış açısından bakılarak oluşur.2.Koşu Dokümanı (Sprint Backlog): Ürün gereksinim dokümanından elde edilmiş iş ve görevleri kapsar. Amacı, sprint sonunda son ürünün bir parçası olan bir işlevselliği ya da çalışabilir bir parçayı elde etmektir. Sprint backlog, sadece takım tarafından değiştirilmektedir.3.Sprint Zaman Grafiği (Burndown Chart): Bu grafik sprint boyunca işlerin ne kadarının yapıldığı ile ne kadarının yapılması gerektiğini karşılaştırmayı sağlar. Yatay ekseninde sprintin günlerini, dikey ekseninde sprintte kalan işi gösteren grafiktir. Scrum’un temel ilkelerinden olan şeffaflığı sağlar.
           Scrum yaklaşımı en popüler Agile yöntemidir.Agile yöntemi ile müşteri doğrudan geliştirme sürecine dahil ediliyor Ve buna ek olarak müşterinin istediği her değişiklik kolaylıkla gerçekleştirilebiliyor.Ekip çalışmasını ön planda tutarak ekip içi iletişimi de geliştirerek sorunların kısa sürede çözümlenmesine olanak sağlıyor.Bu gibi etmenler günümüzde projelerinin başarı oranının artmasına sebep oluyor.Bu yüzden Scrum günümüzde popülerdir.
